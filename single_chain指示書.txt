single_chain関数を実装します。
# single_chain関数は連鎖が起こった時にtrueを、連鎖が起こらなかったときにfalseを返す関数です。
# PlainFieldの値をコピーしたCopyFieldを用意します。
# 処理が終了したのち、連鎖が発生すればPlainFieldにCopyFieldを代入しtrueを返し、そうでないならばfalseを返します。
# i(6..77)に対して幅優先探索を行います。
# CopyField[i]に対し、上はCopyField[i-6], 下はCopyField[i+6]、右はCopyField[i+1]、左はCopyField[i-1]です。
# ただし、配列外参照に注意してください。
# また、ぷよぷよの使用上、0 <= i <= 5 を満たすiの位置にあるぷよは連鎖が発生せず、おじゃまぷよも消えません。
# 探索済みのマスを表すvisited[]変数を用意します。
# つながっているぷよの数を表す変数を用意します。
# 各iに対し、探索予定のマスを入れるqueueなデータ構造を用意し、queueが空になるまで次の処理を繰り返します。
## visited[i] === true なら continue
## j = {iの上下左右}のうち、連鎖が起こる範囲にいるjであり、visited[j] === false なものがあれば queueに追加し、つながっているぷよの個数を1増やし、visited[j] = true とします。
## また、queueに入れられたマスの合計が4以上の時、それらの番号が必要になるので保持してください。
## queueが空になった時、ぷよの連結数が4以上であれば、探索したぷよを"empty"にし、それらの上下左右にあるおじゃまぷよのなかで消える範囲にあるものを"empty"にし、連鎖が起こったことを記録して下さい。
# 上記の処理が終了後、連鎖が起こったのであればPlainFieldにCopyFieldを代入しtrueを返し、そうでないならfalseを返してください。

次の探索先を求める際に、要素をx, yに分割しないようにしたいです。
directions を {-6, 6, -1, 1} で実装することで対応できませんか？